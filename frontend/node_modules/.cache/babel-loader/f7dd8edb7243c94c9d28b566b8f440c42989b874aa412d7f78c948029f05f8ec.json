{"ast":null,"code":"import axios from 'axios';\nimport { io } from 'socket.io-client';\n// API Configuration\nconst API_BASE_URL = process.env.REACT_APP_API_URL || 'https://your-digitalocean-function-url';\nconst WS_URL = process.env.REACT_APP_WS_URL || 'wss://your-websocket-url';\n\n// Axios instance with default config\nconst apiClient = axios.create({\n  baseURL: API_BASE_URL,\n  timeout: 10000,\n  headers: {\n    'Content-Type': 'application/json'\n  }\n});\n\n// Add request interceptor for logging\napiClient.interceptors.request.use(config => {\n  var _config$method;\n  console.log(`API Request: ${(_config$method = config.method) === null || _config$method === void 0 ? void 0 : _config$method.toUpperCase()} ${config.url}`);\n  return config;\n}, error => {\n  console.error('API Request Error:', error);\n  return Promise.reject(error);\n});\n\n// Add response interceptor for error handling\napiClient.interceptors.response.use(response => {\n  return response;\n}, error => {\n  var _error$response;\n  console.error('API Response Error:', error);\n  if (((_error$response = error.response) === null || _error$response === void 0 ? void 0 : _error$response.status) === 401) {\n    // Handle unauthorized access\n    console.warn('Unauthorized access detected');\n  }\n  return Promise.reject(error);\n});\n\n// API Service Class\nexport class ApiService {\n  constructor() {\n    this.socket = null;\n    this.messageHandlers = new Map();\n  }\n  // ==== REST API METHODS ====\n\n  /**\n   * Get current states for all symbols\n   */\n  async getCurrentStates() {\n    try {\n      const response = await apiClient.get('/current-states');\n      return response.data.data || [];\n    } catch (error) {\n      console.error('Error fetching current states:', error);\n      throw this.handleApiError(error);\n    }\n  }\n\n  /**\n   * Get signal history for a specific symbol\n   */\n  async getSignalHistory(symbol, limit = 50) {\n    try {\n      const response = await apiClient.get(`/history/${symbol}?limit=${limit}`);\n      return response.data.data || [];\n    } catch (error) {\n      console.error(`Error fetching history for ${symbol}:`, error);\n      throw this.handleApiError(error);\n    }\n  }\n\n  /**\n   * Get performance metrics\n   */\n  async getPerformanceMetrics(symbol, days = 7) {\n    try {\n      const params = new URLSearchParams();\n      if (symbol) params.append('symbol', symbol);\n      params.append('days', days.toString());\n      const response = await apiClient.get(`/performance?${params.toString()}`);\n      return response.data.data || [];\n    } catch (error) {\n      console.error('Error fetching performance metrics:', error);\n      throw this.handleApiError(error);\n    }\n  }\n\n  /**\n   * Get all active symbols\n   */\n  async getSymbols() {\n    try {\n      const response = await apiClient.get('/symbols');\n      return response.data.data || [];\n    } catch (error) {\n      console.error('Error fetching symbols:', error);\n      throw this.handleApiError(error);\n    }\n  }\n\n  /**\n   * Get timeframes configuration\n   */\n  async getTimeframesConfig() {\n    try {\n      const response = await apiClient.get('/timeframes');\n      return response.data.data || [];\n    } catch (error) {\n      console.error('Error fetching timeframes config:', error);\n      throw this.handleApiError(error);\n    }\n  }\n\n  /**\n   * Health check\n   */\n  async healthCheck() {\n    try {\n      const response = await apiClient.get('/health');\n      return response.data;\n    } catch (error) {\n      console.error('Health check failed:', error);\n      throw this.handleApiError(error);\n    }\n  }\n\n  // ==== WEBSOCKET METHODS ====\n\n  /**\n   * Initialize WebSocket connection\n   */\n  connectWebSocket() {\n    return new Promise((resolve, reject) => {\n      try {\n        this.socket = io(WS_URL, {\n          transports: ['websocket', 'polling'],\n          timeout: 10000,\n          reconnection: true,\n          reconnectionAttempts: 5,\n          reconnectionDelay: 1000\n        });\n        this.socket.on('connect', () => {\n          console.log('WebSocket connected successfully');\n          resolve();\n        });\n        this.socket.on('disconnect', reason => {\n          console.log('WebSocket disconnected:', reason);\n          this.notifyHandlers('disconnect', {\n            reason\n          });\n        });\n        this.socket.on('connect_error', error => {\n          console.error('WebSocket connection error:', error);\n          reject(error);\n        });\n        this.socket.on('message', message => {\n          this.handleWebSocketMessage(message);\n        });\n        this.socket.on('signal_update', data => {\n          this.notifyHandlers('signal_update', data);\n        });\n        this.socket.on('initial_data', data => {\n          this.notifyHandlers('initial_data', data);\n        });\n        this.socket.on('error', error => {\n          console.error('WebSocket error:', error);\n          this.notifyHandlers('error', error);\n        });\n      } catch (error) {\n        console.error('Failed to initialize WebSocket:', error);\n        reject(error);\n      }\n    });\n  }\n\n  /**\n   * Disconnect WebSocket\n   */\n  disconnectWebSocket() {\n    if (this.socket) {\n      this.socket.disconnect();\n      this.socket = null;\n      console.log('WebSocket disconnected');\n    }\n  }\n\n  /**\n   * Subscribe to symbol updates\n   */\n  subscribeToSymbol(symbol) {\n    var _this$socket;\n    if ((_this$socket = this.socket) !== null && _this$socket !== void 0 && _this$socket.connected) {\n      this.socket.emit('subscribe_symbol', {\n        symbol\n      });\n      console.log(`Subscribed to ${symbol} updates`);\n    }\n  }\n\n  /**\n   * Unsubscribe from symbol updates\n   */\n  unsubscribeFromSymbol(symbol) {\n    var _this$socket2;\n    if ((_this$socket2 = this.socket) !== null && _this$socket2 !== void 0 && _this$socket2.connected) {\n      this.socket.emit('unsubscribe_symbol', {\n        symbol\n      });\n      console.log(`Unsubscribed from ${symbol} updates`);\n    }\n  }\n\n  /**\n   * Register message handler\n   */\n  onMessage(type, handler) {\n    this.messageHandlers.set(type, handler);\n  }\n\n  /**\n   * Remove message handler\n   */\n  offMessage(type) {\n    this.messageHandlers.delete(type);\n  }\n\n  /**\n   * Get WebSocket connection status\n   */\n  isConnected() {\n    var _this$socket3;\n    return ((_this$socket3 = this.socket) === null || _this$socket3 === void 0 ? void 0 : _this$socket3.connected) || false;\n  }\n\n  // ==== PRIVATE METHODS ====\n\n  handleWebSocketMessage(message) {\n    console.log('WebSocket message received:', message);\n    this.notifyHandlers(message.type, message.data);\n  }\n  notifyHandlers(type, data) {\n    const handler = this.messageHandlers.get(type);\n    if (handler) {\n      try {\n        handler(data);\n      } catch (error) {\n        console.error(`Error in message handler for ${type}:`, error);\n      }\n    }\n  }\n  handleApiError(error) {\n    if (axios.isAxiosError(error)) {\n      if (error.response) {\n        var _error$response$data;\n        // Server responded with error status\n        const message = ((_error$response$data = error.response.data) === null || _error$response$data === void 0 ? void 0 : _error$response$data.message) || error.response.statusText;\n        return new Error(`API Error (${error.response.status}): ${message}`);\n      } else if (error.request) {\n        // Network error\n        return new Error('Network error: Unable to reach server');\n      }\n    }\n    return error instanceof Error ? error : new Error('Unknown API error');\n  }\n}\n\n// Export singleton instance\nexport const apiService = new ApiService();\n\n// Export helper functions\nexport const formatPrice = price => {\n  return new Intl.NumberFormat('en-US', {\n    style: 'currency',\n    currency: 'USD',\n    minimumFractionDigits: 2,\n    maximumFractionDigits: 8\n  }).format(price);\n};\nexport const formatPercentage = value => {\n  return new Intl.NumberFormat('en-US', {\n    style: 'percent',\n    minimumFractionDigits: 2,\n    maximumFractionDigits: 2\n  }).format(value / 100);\n};\nexport const formatTimestamp = timestamp => {\n  return new Date(timestamp).toLocaleString('en-US', {\n    year: 'numeric',\n    month: 'short',\n    day: 'numeric',\n    hour: '2-digit',\n    minute: '2-digit',\n    second: '2-digit'\n  });\n};","map":{"version":3,"names":["axios","io","API_BASE_URL","process","env","REACT_APP_API_URL","WS_URL","REACT_APP_WS_URL","apiClient","create","baseURL","timeout","headers","interceptors","request","use","config","_config$method","console","log","method","toUpperCase","url","error","Promise","reject","response","_error$response","status","warn","ApiService","constructor","socket","messageHandlers","Map","getCurrentStates","get","data","handleApiError","getSignalHistory","symbol","limit","getPerformanceMetrics","days","params","URLSearchParams","append","toString","getSymbols","getTimeframesConfig","healthCheck","connectWebSocket","resolve","transports","reconnection","reconnectionAttempts","reconnectionDelay","on","reason","notifyHandlers","message","handleWebSocketMessage","disconnectWebSocket","disconnect","subscribeToSymbol","_this$socket","connected","emit","unsubscribeFromSymbol","_this$socket2","onMessage","type","handler","set","offMessage","delete","isConnected","_this$socket3","isAxiosError","_error$response$data","statusText","Error","apiService","formatPrice","price","Intl","NumberFormat","style","currency","minimumFractionDigits","maximumFractionDigits","format","formatPercentage","value","formatTimestamp","timestamp","Date","toLocaleString","year","month","day","hour","minute","second"],"sources":["/Users/Baba/Documents/trading_dashboard/frontend/src/services/api.ts"],"sourcesContent":["import axios from 'axios';\nimport { io, Socket } from 'socket.io-client';\nimport { \n  CurrentState, \n  TradingSignal, \n  PerformanceMetric, \n  Symbol, \n  TimeframeConfig,\n  ApiResponse,\n  WebSocketMessage \n} from '../types';\n\n// API Configuration\nconst API_BASE_URL = process.env.REACT_APP_API_URL || 'https://your-digitalocean-function-url';\nconst WS_URL = process.env.REACT_APP_WS_URL || 'wss://your-websocket-url';\n\n// Axios instance with default config\nconst apiClient = axios.create({\n  baseURL: API_BASE_URL,\n  timeout: 10000,\n  headers: {\n    'Content-Type': 'application/json',\n  },\n});\n\n// Add request interceptor for logging\napiClient.interceptors.request.use(\n  (config) => {\n    console.log(`API Request: ${config.method?.toUpperCase()} ${config.url}`);\n    return config;\n  },\n  (error) => {\n    console.error('API Request Error:', error);\n    return Promise.reject(error);\n  }\n);\n\n// Add response interceptor for error handling\napiClient.interceptors.response.use(\n  (response) => {\n    return response;\n  },\n  (error) => {\n    console.error('API Response Error:', error);\n    if (error.response?.status === 401) {\n      // Handle unauthorized access\n      console.warn('Unauthorized access detected');\n    }\n    return Promise.reject(error);\n  }\n);\n\n// API Service Class\nexport class ApiService {\n  private socket: Socket | null = null;\n  private messageHandlers: Map<string, (data: any) => void> = new Map();\n\n  // ==== REST API METHODS ====\n\n  /**\n   * Get current states for all symbols\n   */\n  async getCurrentStates(): Promise<CurrentState[]> {\n    try {\n      const response = await apiClient.get<ApiResponse<CurrentState[]>>('/current-states');\n      return response.data.data || [];\n    } catch (error) {\n      console.error('Error fetching current states:', error);\n      throw this.handleApiError(error);\n    }\n  }\n\n  /**\n   * Get signal history for a specific symbol\n   */\n  async getSignalHistory(symbol: string, limit: number = 50): Promise<TradingSignal[]> {\n    try {\n      const response = await apiClient.get<ApiResponse<TradingSignal[]>>(\n        `/history/${symbol}?limit=${limit}`\n      );\n      return response.data.data || [];\n    } catch (error) {\n      console.error(`Error fetching history for ${symbol}:`, error);\n      throw this.handleApiError(error);\n    }\n  }\n\n  /**\n   * Get performance metrics\n   */\n  async getPerformanceMetrics(symbol?: string, days: number = 7): Promise<PerformanceMetric[]> {\n    try {\n      const params = new URLSearchParams();\n      if (symbol) params.append('symbol', symbol);\n      params.append('days', days.toString());\n\n      const response = await apiClient.get<ApiResponse<PerformanceMetric[]>>(\n        `/performance?${params.toString()}`\n      );\n      return response.data.data || [];\n    } catch (error) {\n      console.error('Error fetching performance metrics:', error);\n      throw this.handleApiError(error);\n    }\n  }\n\n  /**\n   * Get all active symbols\n   */\n  async getSymbols(): Promise<Symbol[]> {\n    try {\n      const response = await apiClient.get<ApiResponse<Symbol[]>>('/symbols');\n      return response.data.data || [];\n    } catch (error) {\n      console.error('Error fetching symbols:', error);\n      throw this.handleApiError(error);\n    }\n  }\n\n  /**\n   * Get timeframes configuration\n   */\n  async getTimeframesConfig(): Promise<TimeframeConfig[]> {\n    try {\n      const response = await apiClient.get<ApiResponse<TimeframeConfig[]>>('/timeframes');\n      return response.data.data || [];\n    } catch (error) {\n      console.error('Error fetching timeframes config:', error);\n      throw this.handleApiError(error);\n    }\n  }\n\n  /**\n   * Health check\n   */\n  async healthCheck(): Promise<any> {\n    try {\n      const response = await apiClient.get<ApiResponse<any>>('/health');\n      return response.data;\n    } catch (error) {\n      console.error('Health check failed:', error);\n      throw this.handleApiError(error);\n    }\n  }\n\n  // ==== WEBSOCKET METHODS ====\n\n  /**\n   * Initialize WebSocket connection\n   */\n  connectWebSocket(): Promise<void> {\n    return new Promise((resolve, reject) => {\n      try {\n        this.socket = io(WS_URL, {\n          transports: ['websocket', 'polling'],\n          timeout: 10000,\n          reconnection: true,\n          reconnectionAttempts: 5,\n          reconnectionDelay: 1000,\n        });\n\n        this.socket.on('connect', () => {\n          console.log('WebSocket connected successfully');\n          resolve();\n        });\n\n        this.socket.on('disconnect', (reason) => {\n          console.log('WebSocket disconnected:', reason);\n          this.notifyHandlers('disconnect', { reason });\n        });\n\n        this.socket.on('connect_error', (error) => {\n          console.error('WebSocket connection error:', error);\n          reject(error);\n        });\n\n        this.socket.on('message', (message: WebSocketMessage) => {\n          this.handleWebSocketMessage(message);\n        });\n\n        this.socket.on('signal_update', (data) => {\n          this.notifyHandlers('signal_update', data);\n        });\n\n        this.socket.on('initial_data', (data) => {\n          this.notifyHandlers('initial_data', data);\n        });\n\n        this.socket.on('error', (error) => {\n          console.error('WebSocket error:', error);\n          this.notifyHandlers('error', error);\n        });\n\n      } catch (error) {\n        console.error('Failed to initialize WebSocket:', error);\n        reject(error);\n      }\n    });\n  }\n\n  /**\n   * Disconnect WebSocket\n   */\n  disconnectWebSocket(): void {\n    if (this.socket) {\n      this.socket.disconnect();\n      this.socket = null;\n      console.log('WebSocket disconnected');\n    }\n  }\n\n  /**\n   * Subscribe to symbol updates\n   */\n  subscribeToSymbol(symbol: string): void {\n    if (this.socket?.connected) {\n      this.socket.emit('subscribe_symbol', { symbol });\n      console.log(`Subscribed to ${symbol} updates`);\n    }\n  }\n\n  /**\n   * Unsubscribe from symbol updates\n   */\n  unsubscribeFromSymbol(symbol: string): void {\n    if (this.socket?.connected) {\n      this.socket.emit('unsubscribe_symbol', { symbol });\n      console.log(`Unsubscribed from ${symbol} updates`);\n    }\n  }\n\n  /**\n   * Register message handler\n   */\n  onMessage(type: string, handler: (data: any) => void): void {\n    this.messageHandlers.set(type, handler);\n  }\n\n  /**\n   * Remove message handler\n   */\n  offMessage(type: string): void {\n    this.messageHandlers.delete(type);\n  }\n\n  /**\n   * Get WebSocket connection status\n   */\n  isConnected(): boolean {\n    return this.socket?.connected || false;\n  }\n\n  // ==== PRIVATE METHODS ====\n\n  private handleWebSocketMessage(message: WebSocketMessage): void {\n    console.log('WebSocket message received:', message);\n    this.notifyHandlers(message.type, message.data);\n  }\n\n  private notifyHandlers(type: string, data: any): void {\n    const handler = this.messageHandlers.get(type);\n    if (handler) {\n      try {\n        handler(data);\n      } catch (error) {\n        console.error(`Error in message handler for ${type}:`, error);\n      }\n    }\n  }\n\n  private handleApiError(error: any): Error {\n    if (axios.isAxiosError(error)) {\n      if (error.response) {\n        // Server responded with error status\n        const message = error.response.data?.message || error.response.statusText;\n        return new Error(`API Error (${error.response.status}): ${message}`);\n      } else if (error.request) {\n        // Network error\n        return new Error('Network error: Unable to reach server');\n      }\n    }\n    \n    return error instanceof Error ? error : new Error('Unknown API error');\n  }\n}\n\n// Export singleton instance\nexport const apiService = new ApiService();\n\n// Export helper functions\nexport const formatPrice = (price: number): string => {\n  return new Intl.NumberFormat('en-US', {\n    style: 'currency',\n    currency: 'USD',\n    minimumFractionDigits: 2,\n    maximumFractionDigits: 8,\n  }).format(price);\n};\n\nexport const formatPercentage = (value: number): string => {\n  return new Intl.NumberFormat('en-US', {\n    style: 'percent',\n    minimumFractionDigits: 2,\n    maximumFractionDigits: 2,\n  }).format(value / 100);\n};\n\nexport const formatTimestamp = (timestamp: string): string => {\n  return new Date(timestamp).toLocaleString('en-US', {\n    year: 'numeric',\n    month: 'short',\n    day: 'numeric',\n    hour: '2-digit',\n    minute: '2-digit',\n    second: '2-digit',\n  });\n}; "],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}